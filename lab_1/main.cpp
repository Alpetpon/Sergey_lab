#include "myRect.h"
#include "myString.h"
#include <iostream>


using namespace std;

//Задание 7
class Bochka {
private:
	double volume;  // объем бочки в литрах
	double concentration;  // концентрация вещества в бочке (в процентах)
	
public:
	Bochka(double initialVolume, double initialConcentration)
	: volume(initialVolume), concentration(initialConcentration) {}
	
	double GetVolume() const {
		return volume;
	}
	
	double GetConcentration() const {
		return concentration;
	}
	
	void Pereliv(Bochka& other) {
		double perelivVolume = 1.0;  // объем кружки
		double transferredConcentration = (concentration * perelivVolume) / volume;
		
		concentration -= transferredConcentration;
		volume -= perelivVolume;
		
		other.concentration += transferredConcentration;
		other.volume += perelivVolume;
	}
};

class IterativePereliv {
public:
	static int FindIterationNumber(Bochka& spirt, Bochka& water) {
		int iteration = 0;
		
		while (spirt.GetConcentration() > 50.0) {
			spirt.Pereliv(water);
			water.Pereliv(spirt);
			
			iteration++;
		}
		
		return iteration;
	}
};



int main()
{


	//Задание 1.Объявление класса. Создание экземпляра класса.
	//Вызов методов класса. 
	//Откройте закладку Class View - (здесь Вы увидите имена методов и
	//данных - классов Rect и MyString)
	//Обратите внимание на пиктограммы слева от имен членов класса - они
	//обозначают спецификатор доступа к каждому члену класса.

	//Какой конструктор вызывается при создании экземпляра класса?
	{
		Rect rect;//Вызывается конструктор без параметров
	}

	//1a. Объявите и определите конструктор с параметрами для
	//инициализации переменных класса. Создайте экземляры класса Rect
	//с помощью конструктора с параметрами. Если компилятор выдает
	//ошибку в предыдущем фрагменте, подумайте - чего ему не
	//хватает? Добейтесь отсутствия ошибок.
	//Выполняя задание с самого начала по шагам, определите:
	//в какой момент происходит вызов конструктора(какого?)?

	//Замечание*: хорошо было бы учесть тот факт, что прямоугольник
	//может оказаться "ненормализованным", то есть m_left>m_right или/и
	//m_top>m_bottom
	//Подсказка: учтите, что пользователь Вашего класса может указывать
	//в качестве параметров любые значения! Например:
	
	// Rect rrr(4,3,2,1);
	

	//1б. При конструировании объекта посредством конструктора без параметров
	//предусмотрите инициализацию переменных класса, например, нулем

	
	
	//1в. Объявите, определите и вызовите метод класса InflateRect(), 
	//который увеличивает размеры прямоугольника на заданные приращения
	//(раздвигая стороны от центра - каждую сторону на свое значение).
	//Подсказка: объявить и определить методы можно не только "вручную",
	//но и с помощью Wizard-a Class View. Для этого: откройте закладку
	//ClassView окна проекта, сделайте активным класс Rect и нажмите
	//правую кнопку мыши - в появившемся контекстном меню выберите
	//Add/Add Member Function... С помощью появившейся диалоговой панели
	//"дайте указания" Wizard-у как объявить и определить метод.

	{
		// 1. Создание экземпляра класса Rect с использованием конструктора без параметров
		Rect rect1;
		rect1.PrintRect();
		
		// 1а. Создание экземпляра класса Rect с использованием конструктора с параметрами
		Rect rect2(4, 2, 3, 1);
		rect2.PrintRect();
		
		// 1в. Вызов метода InflateRect() для увеличения размеров прямоугольника
		rect2.InflateRect(1, 1);
		rect2.PrintRect();
	}

	



	//Задание 2.Перегрузка конструкторов и методов класса.
	//Конструктор копирования.

	//2а.Объявите и определите конструктор копирования в классе Rect.
	//Выполняя задание по шагам, определите, какой
	//конструктор вызывается при создании r1,r2,r3 и r4?
	//Чему равны переменные созданных объектов?
	// 2. Конструкторы и конструктор копирования
		Rect r1;
		Rect r2(1, 2, 3, 4);
		Rect r3 = r1;
		Rect r4(r2);
		
		
		std::cout << "r1: ";
		r1.PrintRect();
		
		std::cout << "r2: ";
		r2.PrintRect();
		
		std::cout << "r3: ";
		r3.PrintRect();
		
		std::cout << "r4: ";
		r4.PrintRect();

	
  //2б. Объявите и определите в классе Rect метод InflateRect(),
	//который принимает два аргумента, по умолчанию равных 1, и 
	//раздвигает стороны прямоугольника на на заданные приращения.
	//Для каких объектов вызывается функция InflateRect()?
		// 2б. Метод InflateRect()
		// 2б. Метод InflateRect()
	
		r1.InflateRect(1, 1);
		r2.InflateRect(2, 2);
		
		std::cout << "r1 after InflateRect: ";
		r1.PrintRect();
		
		std::cout << "r2 after InflateRect: ";
		r2.PrintRect();
		
		Rect r3;
		r3.InflateRect(2, 2, 2, 2);
		r3.InflateRect(3, 3);
		r3.InflateRect(5);
		r3.InflateRect();
	
		std::cout << "r3 after multiple InflateRect calls: ";
		r3.PrintRect();	
	
	


	//Задание 3.Спецификаторы доступа. Инкапсуляция. 
	{
	Rect r;
	//Раскомментируйте следующую строку. Объясните ошибку
	//компилятора
	//int tmp = r.m_left;
		/*
		Данная строка int tmp = r.m_left; вызовет ошибку компиляции, так как m_left является членом класса Rect, объявленным с модификатором private.
		
		Спецификатор доступа private означает, что члены класса (переменные или функции) с этим модификатором доступа могут быть использованы только внутри самого класса, но не снаружи. Таким образом, попытка обращения к m_left вне класса приводит к ошибке компиляции, поскольку переменные с private доступом недоступны за пределами класса, где они объявлены.
		*/



	//Введите в класс Rect метод void SetAll(...),
	//который присваивают переменным класса передаваемые
	//значения. Вызовите созданный метод, проверьте корректность. 
	// Вызовите методы SetAll и GetAll для проверки корректности
		r.SetAll(1, 2, 3, 4);
		int left, right, top, bottom;
		
		
		

	//Введите в класс Rect парный метод GetAll(...),
	//который "достает" значения private-переменных класса.
	//Вызовите созданный метод, проверьте корректность. 
		r.GetAll(left, right, top, bottom);
		
		// 2б. Метод InflateRect()
		r.InflateRect(1, 1);  // Вызывается метод для r
		r.PrintRect();
	}


	//Задание 4.Передача экземпляра класса в качестве параметра
	//функции. Возвращение объекта класса по значению. Поставив
	//остановы в конструкторе копирования или выполняя фрагмент
	//по шагам, определите: в какой момент происходит обращение
	//к конструктору копирования. 
	//Создайте глобальную функцию 
	// Rect BoundingRect(Rect, Rect);
	//которая принимает два объекта класса Rect по значению и
	//возвращает объект класса Rect, который является прямоугольником,
	//в который вписаны заданные прямоугольники. Как происходит
	//передача параметров и возвращение объекта класса?



	{

		Rect r1(1, 2, 3, 4), r2(5, 6, 7, 8), r3;
		
			
	//Задание 4а. Передача объектов по ссылке.
	//Создайте глобальную функцию BoundingRect2, которая выполняет ту же
	//задачу, принимая параметры по ссылке
	//Вызываются ли конструкторы при передаче параметров?
	
	//Задание 4б.Реализуйте ту же задачу (BoundingRect) методом класса
	

		// Глобальная функция BoundingRect
		r3 = BoundingRect(r1, r2);
		r3.PrintRect();
		
		// Глобальная функция BoundingRect2
		r3 = BoundingRect2(r1, r2);
		r3.PrintRect();

	}

	



	//Задание 5. Когда вызываются конструкторы и деструкторы.
	//Объявите и определите
	//явный деструктор класса. Поставьте остановы в 
	//конструкторе (конструкторах) и деструкторе. Определите: когда для
	//каждого из объектов вызывается конструктор, а когда - деструктор?
	{
		Rect r1;
		Rect*	pR = new Rect(1,2,1,2);	
		{
			Rect r2(r1);
			Rect arRect[2];
			for(int i=0; i<3; i++)
				{
					static Rect r3 (i,i,i,i) ;
					Rect r4(*pR);
					Rect r5(i,i,i,i);
				}
		}
		delete pR;	
	}


	//Задание 6.Конструктор + деструктор = функциональное
	// замыкание. Класс MyString
	// Посредством конструктора (конструкторов) и деструктора обеспечьте
	//корректные инициализацию и деактивацию объекта
	//C помощью остановов определите когда происходит
	//захват и освобождение памяти для строки-члена класса
	{
		MyString	str1("It's my string1!");
		//Создайте метод GetString(), который обеспечит доступ к хранящейся строке.
		//С помощью cout и метода GetString() распечатайте строку объекта str1
		//Замечание: подумайте, как следует корректно реализовать метод GetString().

		//Подсказка 1:
		//приведенный ниже код должен работать:
		std::cout<<str1.GetString()<<std::endl;

		//Подсказка 2:
		//приведенный ниже код НЕ должен работать:
		str1.GetString()[1] = 'W';

		//Подсказка 3:
		//приведенный ниже код должен работать:
		const MyString	str2("It's my string2!");
		std::cout<<str2.GetString()<<std::endl;
		
	}


	//6a. Раскомментируйте следующий фрагмент. Подумайте - какие
	//неприятности Вас ожидают. Попробуйте исправить положение (как?)
		{
			MyString str1("The first string!");
			MyString str2 = str1;
		}

	//6б. Реализуйте метод SetNewString, который будет заменять строку
	// на новую
	MyString str3("Original String");
	std::cout << "Original String: " << str3.GetString() << std::endl;
	
	// Изменяем строку с помощью SetNewString
	str3.SetNewString("Updated String");
	std::cout << "Updated String: " << str3.GetString() <




	//Задание 7.  Решите с помощью классов следующую задачу:
	//даны две бочки известного объема. В одной бочке в начальный момент
	//времени содержится спирт (96%), в другой – вода.
	//Кружкой емкостью 1л переливаем итеративно содержимое из одной бочки
	//в другую следующим способом: на каждой итерации
	//зачерпнули из первой бочки -> вылили во вторую
	//зачерпнули из второй бочки -> вылили в первую.
	//Требуется определить номер итерации, на которой концентрация спирта в
	//первой бочке станет меньше 50%.

	Bochka spirt(10.0, 96.0);
	Bochka water(10.0, 0.0);
	
	int iteration = IterativePereliv::FindIterationNumber(spirt, water);
	
	std::cout << "Number of iterations: " << iteration << std::endl;

return 0;

}//end_main
